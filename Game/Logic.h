// Функция calc_score вычисляет оценку текущей позиции на доске.
// Она учитывает количество фигур и их тип для обоих игроков.
// Параметры:
//   - mtx: матрица, представляющая текущее состояние доски.
//   - first_bot_color: цвет первого игрока (бота).
// Возвращает оценку позиции в виде числа с плавающей запятой.
// Чем больше оценка, тем лучше позиция для первого игрока.
double calc_score(const vector<vector<POS_T>>& mtx, const bool first_bot_color) const
{
    double w = 0, wq = 0, b = 0, bq = 0; // Счетчики для белых и черных фигур
    // Проходим по всей доске
    for (POS_T i = 0; i < 8; ++i)
    {
        for (POS_T j = 0; j < 8; ++j)
        {
            w += (mtx[i][j] == 1); // Подсчет обычных белых фигур
            wq += (mtx[i][j] == 3); // Подсчет ферзей белых
            b += (mtx[i][j] == 2); // Подсчет обычных черных фигур
            bq += (mtx[i][j] == 4); // Подсчет ферзей черных
            // Если режим оценки "Число и Потенциал"
            if (scoring_mode == "NumberAndPotential")
            {
                w += 0.05 * (mtx[i][j] == 1) * (7 - i); // Потенциальная оценка для белых
                b += 0.05 * (mtx[i][j] == 2) * (i); // Потенциальная оценка для черных
            }
        }
    }
    // Меняем местами оценки, если второй игрок - это бот
    if (!first_bot_color)
    {
        swap(b, w);
        swap(bq, wq);
    }
    // Если нет фигур у одного из игроков, возвращаем бесконечность
    if (w + wq == 0)
        return INF;
    if (b + bq == 0)
        return 0; // Если нет фигур у первого игрока, оценка равна 0
    int q_coef = 4; // Коэффициент для ферзей
    if (scoring_mode == "NumberAndPotential")
    {
        q_coef = 5; // Изменяем коэффициент для режима "Число и Потенциал"
    }
    // Возвращаем оценку позиции
    return (b + bq * q_coef) / (w + wq * q_coef);
}

// Функция make_turn применяет указанный ход к матрице мапы.
// Если ход приводит к побеждению, фигура, которая была побеждена, удаляется.
// Параметры:
//   - mtx: матрица, представляющая текущее состояние доски.
//   - turn: структура, содержащая информацию о ходе (координаты старта и конца).
// Возвращает обновленную матрицу с примененным ходом к ней.
vector<vector<POS_T>> make_turn(vector<vector<POS_T>> mtx, move_pos turn) const
{
    if (turn.xb != -1) // Если был побеждённый ход
        mtx[turn.xb][turn.yb] = 0; // Убираем побежденную фигуру

    // Условия для обновления типа фигуры (проверка на коронацию)
    if ((mtx[turn.x][turn.y] == 1 && turn.x2 == 0) || (mtx[turn.x][turn.y] == 2 && turn.x2 == 7))
        mtx[turn.x][turn.y] += 2; // Повышаем фигуру до ферзя

    // Перемещаем фигуру в новую позицию
    mtx[turn.x2][turn.y2] = mtx[turn.x][turn.y]; // Устанавливаем фигуру в новую позицию
    mtx[turn.x][turn.y] = 0; // Сбрасываем старую позицию

    return mtx; // Возвращаем обновленную матрицу
}
